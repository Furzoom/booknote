# 函数link、linkat、unlink、unlinkat和remove



```c
#include <unistd.h>
int link(const char *existingpath, const char *newpath);
int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);
```

* 成功返回0，出错返回-1。

这两个函数创建一个新的目录项newpath，这引用现有文件existingpath。如果newpath已经存在，则返回出错。只会创建newpath中的最后一个分量，路径中的其他部分应当已经存在。

对于linkat函数，现在文件是通过nfd和existingpath参数指定的，新的路径名是通过nfd和newpath参数指定的。默认情况下，如果两个路径名的任一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为`AT_FDCWD`，那么相对应的路径名就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。

当现有文件是符号链接时，由flag参数来控制linkat函数是创建指向现有符号链接的链接还是创建指向现在符号链接所指向的文件的链接。如果在flag参数中设置了`AT_SYMLINK_FOLLOW`标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。

创建新目录项和增加链接计数应当是一个原子操作。

为了删除一个现有的目录项，可以调用unlink函数。

```c
#include <unistd.h>
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);
```

* 成功返回0，出错返回-1。

这两个函数删除目录项，并将由pathname所引用的文件的链接计算减1。如果该文件还有其他链接，则仍可以通过其他链接访问该文件数据。如果出错，则不对该文件进行任何更改。

为了解除对文件链接，必须对包含目录项的目录具有写和执行权限。

如果对该目录设置了粘着位，则对该目录必须具有写权限，且具备以下三个条件之一：

* 拥有该文件。
* 拥有该目录。
* 具有超级用户权限。

只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件内容，只要有进程打开了该文件，则内容也不能被删除。关闭文件时，进程首先检查打开该文件的进程个数。如果这个计数达到0，内核再去检查其链接计数。如果计数也是0，那么就删除该文件的内容。

如果pathname参数是相对路径，那么unlinkat函数计算相对于由fd文件描述参数代表的目录的路径名。如果fd参数设置为`AT_FDCWD`，那么通过相对于调用进程当前工作目录计算路径名。如果pathname参数是绝对路径名，那么fd参数被忽略。

如果flag参数的`AT_REMOVEDIR`标志被设置时，unlinkat函数可以类似于rmdir一样删除目录。如果这个标志被清除，则unlinkat与unlink执行同样的操作。

unlink的这种特性经常被程序用来确保即使是程序崩溃时，它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件后，然后立即调用unlink，因为该文件仍旧是打开的，所有不会将其内容删除。只有当进程关闭该文件或者终止时，该文件的内容才被删除。

如果pathname是符号链接，那么unlink删除该符号链接，而不是删除该符号链接引用的文件。给出符号链接名的情况下，没有一个函数能删除由该符号链接引用的文件。

如果操作系统支持，超级用户可以使用unlink删除目录。

也可以使用remove函数解除对一个文件或目录的链接。对于文件，remove的功能与unlink相同。对于目录，remove与rmdir相同。

```c
#include <stdio.h>
int remove(const char *pathname);
```

* 成功返回0，出错返回-1。
