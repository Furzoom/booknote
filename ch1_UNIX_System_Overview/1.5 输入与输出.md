# 输入与输出

## 文件描述符

文件描述符(file descriptor)通常是一个小的非负整数，内核用它标识特定进程正在访问的文件。当内核打开一个已存在文件或创建一个新文件时，它返回一个文件描述符，进程使用它来读、写文件。

## 标准输入、标准输出、标准错误

每运行一个新的程序时，所有的shell都为其打开三个文件描述符：standard input、standard output、standard error。

可以使用`<`、`>`、`2>`对标准输入、标准输出和标准错误进行重定向。

## 不用缓冲的I/O

函数open, read, write, lseek, close提供了不用缓冲的I/O。这些函数都使用描述符。

`STDIN_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO`是定义在\<unistd.h\>中的文件描述符。典型值为0、1、2。

`read`函数返回读取的字节数，读到文件结尾时，返回0，出错返回-1。

在shell中使用`ctrl+D`输入文件结束符。

```c
#include <unistd.h>
// read from a file descriptor
ssize_t read(int fd, void *buf, size_t count);
```
* fd
	* file descriptor read from
* buf
	* buffer which read into
* count
	* read max count bytes
* return
	* number of bytes read on success. On error, -1 is returned.


```c
#include <unistd.h>
// write to a file descriptor
ssize_t write(int fd, const void *buf, size_t count);
```
* fd
	* file descriptor write to
* buf
	* buffer what to write
* count
	* write max count bytes
* return
	* number of bytes write on success. On error, -1 is returned.

```c
#include <unistd.h>
// close a file descriptor
int close(int fd);
```

## 标准I/O

标准I/O提供了无缓冲I/O函数的带缓冲接口。提供以下几组函数。

```c
#include <stdio.h>
// check and reset stream status
int ferror(FILE *stream);
int feof(FILE *stream);
int fileno(FILE *stream);
void clearerr(FILE *stream);
```

* clearerr() clears the end-of-file and error indicators for the stream pointed to by tream.
* ferror() tests the error indicator for the stream pointed to by stream, reutrning non-zero if it is set.
* feof() tests the end-of-file indicator for the stream pointed to by stream, returning non-zero if it is set.
* fileno() examines the argument stream and returns its integer descriptor.

```c
#include <stdio.h>
// input of characters and strings
int getc(FILE *stream);
int fgetc(FILE *stream);
int getchar(void);
```

* fgetc() reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
* getc() is equivalent to fgetc() except that it may be implement as a macro which evaluates stream more than once.
* getchar() is equivalent to getc(stdin).

**NB**: 优先使用`fgetc()`。

```c
#include <stdio.h>
char *gets(char *s);
char *fgets(char *s, int size, FILE *stream);
```

* gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with '\0'. No check for buffer overrun is performed.
* fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed by s. Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A '\0' is stored after the last character in the buffer.
* They return s on success, and NULL on error or when end of file occurs while no characters have been read.


**NB**:1. 对行尾的newline处理的不同。 2. 避免使用`gets()`。

```c
#include <stdio.h>
int ungetc(int c, FILE *stream);
```

* ungetc() pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations. Pushed-back characters will be returned  in reverse order; only one pushback is guaranteed.
* It returns c on success, or EOF on error.


```c
#include <stdio.h>
int putc(int c, FILE *stream);
int fputc(int c, FILE *stream);
int putchar(int c);
```

* putc() is equivalent to fputc() except that is may be implemented as a macro which evaluates stream more than once.
* fputc() writes the character c, cast to an unsigned char, to stream.
* putchar() is equivalent to putc(c, stdout).
* They return the character written as an unsigned char cast to an int or EOF on error.

**NB**:优先使用`fputc()`。

```c
#include <stdio.h>
int puts(const char *s);
int fputs(const char *s, FILE *stream);
```

* puts() writes the string s and a trailing newline to stdout.
* fputs() writes the string s to stream, without its trailing '\0'.
* They return a non-negative number on success, or EOF on error.

**NB**: `puts()`与`fputs()`对行尾处理的不同。
